
The SOLID principles are five design principles to make software more understandable, flexible, and maintainable. They were first introduced by Robert C. Martin, a.k.a., "Uncle Bob".

SOLID Principles
- [Single Responsibility Principle](#single-responsibility-principle)
- [Open/Closed Principle](#openclosed-principle)
- [Liskov Substituion Principle](#liskov-substituion-principle)
- [Interface Segration Principle](#interface-segration-principle)
- [Dependency Inversion Principle](#dependency-inversion-principle)

## Single Responsibility Principle
- Description: A class should have one reason to change. It should have one responsibility.
- Benefit: This makes the class easier to understand and reduces the impact of changes.
- Example: TODO

## Open/Closed Principle
- Description: Software entities (classes, functions, modules, etc.) should be open for extension but closed for modification. This means that you can add new functionality without changing existing code.
- Benefit: It promotes modular structure and reduces the risk of breaking changes.
- Example: TODO

## Liskov Substition Principle
- Description: Objects in a program should be replaceable with instances of their subtypes without altering the correctness of the program.
- Benefit: This reduces unintended side effects by ensuring that a derived class does not affect the behavior and expectations of the existing base class.
- Example: TODO

## Interface Segration Principle
- Description: No client should depend on methods it does not use. Instead of one large interface, multiple small interfaces are preferred.
- Benefit: Promotes more decoupled systems and fine-grained control over the functionalities that a class needs to implement. This makes the system more understandable and less prone to errors.
- Example: TODO

## Dependency Inversion Principle
- Description: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details; details should depend on abstractions.
- Benefit: Reduces the direct dependency between high-level and low-level modules.
- Example: TODO

# Dependency Inject vs Dependency Inversion Principle
- *TODO*
- Example: TODO
